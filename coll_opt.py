# -*- coding: utf-8 -*-
"""Collateral Optimization.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_-JldfzjU_drpZsZ3IxCA1IDMRLplcqJ
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import minimize
import json

# Load real-time parameters from JSON files
with open("aave_params.json", "r") as f:
    aave_params = json.load(f)

with open("comp_params.json", "r") as f:
    compound_params = json.load(f)

with open("fluid_params.json", "r") as f:
    fluid_params = json.load(f)

#print(aave_params)
#print(compound_params)


# Define constants
"""b = 108000000
a = 0.9123*b
d = 18980000
c = 0.8781*d
T = 1000000
R0c = 0.003
R1c = 0.039
R0a = 0.0001
R1a = 0.0549
R2a = 2
R2c = 2
rf=0.1"""

# Assign parameters
rf_a = aave_params["rf"]
R0a = aave_params["R0a"]
R1a = aave_params["R1a"]
R2a = aave_params["R2a"]
a = aave_params["a"]
b = aave_params["b"]

c = compound_params["c"]
d = compound_params["d"]
R0c = compound_params["R0c"]
R1c = compound_params["R1c"]
R2c = compound_params["R2c"]

e = fluid_params["totBorrow"]
f = fluid_params["totSupply"]
R0f = fluid_params["rateAtUtilizationZero"]
R1f = fluid_params["rateAtUtilizationKink1"]
R2f = fluid_params["rateAtUtilizationKink2"]
R3f = fluid_params["rateAtUtilizationMax"]
rf_f = fluid_params["rf"]
k1 = fluid_params["k1"]
k2 = fluid_params["k2"]


T = 100000

#S_A and S_C as functions of x
def SA(x):
    if((a/(b+x))<0.9):
        return ((a / (b + x)) * (R0a + (a / (b + x)) * (10 * R1a / 9)))*(1 - rf_a)
    else:
        return ((a / (b + x)) * (R0a + R1a + (10*((a / (b + x)) - 0.9)) * R2a))*(1 - rf_a)

def SC(x):
    if((c / (d + T - x)) < 0.85):
        return (R0c + ((c / (d + T - x)) * R1c))
    else:
        return (R0c + (R1c*0.85) + (R2c*((c / (d + T - x))-0.85)))
    
def SF(x):
    U = e / (f + x)
    if(U <= 0.85):
        return (U ** 2) * ((R1f - R0f) / k1) * (1 - rf_f)
    elif(U > 0.85 and U <= 0.93):
        return R1f + (((R2f - R1f)/(k2 - k1)) * (U - k1) * U) * (1 - rf_f)
    else:
        return R2f + (((R3f - R2f) / (1 - k2)) * (U - k2) * U) * (1 - rf_f)

# Define the profit function
# Define the updated profit function
def profit(xy):
    x, y = xy  # Split input variables
    return (x * SA(x)) + (y * SF(y)) + ((T - x - y) * SC(x + y))

# Define the negative profit (to maximize profit using minimization)
def neg_profit(xy):
    return -profit(xy)

# Constraints: x + y <= T
constraints = [
    {'type': 'ineq', 'fun': lambda xy: T - xy[0] - xy[1]}  # x + y <= T
]

# Set bounds for x and y
bounds = [(0, T), (0, T)]  # Both x and y must be between 0 and T

# Initial guess for x and y
x0 = [T / 3, T / 3]  # Initial guess evenly splitting T into x and y

# Perform the optimization
result = minimize(
    neg_profit,          # Objective function
    x0,                  # Initial guess
    method='trust-constr',
    bounds=bounds,       # Bounds for variables
    constraints=constraints,  # Constraints
    options={'verbose': 1}    # Verbosity for detailed output (optional)
)

# Extract optimal x, y, and maximum profit
optimal_x = result.x[0]
optimal_y = result.x[1]
max_profit = -result.fun

results = {
    "Initial Supply APR on Aave": SA(0),
    "Initial Supply APR on Compound": SC(T),
    "Initial Supply APR on Fluid": SF(0),
    "Deposit on Aave": optimal_x,
    "Deposit on Fluid": optimal_y,
    "Deposit on Compound": T - optimal_x - optimal_y,
    "Maximum Profit": max_profit,
    "Final Supply APR on Aave": SA(optimal_x),
    "Final Supply APR on Fluid": SF(optimal_y),
    "Final Supply APR on Compound": SC(optimal_x + optimal_y),
}

print(json.dumps(results, indent=2))

"""x = np.linspace(0, T, 100)
y = np.linspace(0, T, 100)
X, Y = np.meshgrid(x, y)

# Calculate Z (profit values) for the grid
Z = np.zeros_like(X)

max=0
x_max=0
y_max=0

for i in range(X.shape[0]):
    for j in range(X.shape[1]):
        if X[i, j] + Y[i, j] <= T:  # Ensure x + y <= T
            Z[i, j] = profit([X[i, j], Y[i, j]])
            if Z[i,j]>max:
                max=Z[i,j]
                x_max=X[i,j]
                y_max=Y[i,j]
        else:
            Z[i, j] = np.nan  # Exclude invalid points where x + y > T

print(max, x_max, y_max)"""
